# 数据库设计那些事

```ini
时间:2020年12月15日11:11:46
作者:王晨
慕课网地址:https://www.imooc.com/learn/117
```



## 1. 需求分析

### 1.1 数据库设计简介

- 关系型数据库 MySQL、Oracle、SQLServer、PgSql
- NoSQL系统：MongoDB、Memcache、Redis
- 目的：有效的对应用系统中的数据进行存储，并可以高效的对已经存储的数据进行访问
- 优良的设计：减少数据冗余、避免数据维护异常、节约存储空间、高效的访问

### 1.2 数据库设计的步骤

需求分析=>逻辑设计=>物理设计=>维护优化

### 1.3 需求分析重要性简介

- 了解系统中所要存储的数据
- 了解数据的存储特点
- 了解数据的生命周期



- 搞清楚一些问题
  - 实体与实体之间的关系（1对1、1对多、多对多）
  - 实体所包含的属性有什么
  - 那些属性或属性的组合可以唯一标识一个实体
  - 

### 1.4 需求分析举例

电子商务网站：

- 用户模块
  - 包括属性：用户名、密码、电话、。。。
  - 可选唯一标识属性：用户名、身份证、电话
  - 存储特点：随系统上线时间逐渐增加，需要永久存储
- 商品模块
  - 属性：商品编码、商品名称、供应商、商品描述、
  - 可选唯一标识属性：（商品名称、供应商），商品编码
  - 存储特点：对于下线商品可以归档存储
- 订单模块
  - 属性：订单号、用户姓名、用户电话、收货地址、商品编号、订单状态、支付状态、订单类型
  - 可选唯一标识属性：订单号
  - 存储特点：永久存储（分表、分库）
- 购物车模块
  - 属性：用户名、商品编号、名称、价格
  - 可选唯一标识：（用户名、商品编号、加入时间），购物车编号
  - 存储特点：不用永久存储（设置归档、清理原则）
- 供应商模块
  - 属性：供应商编号、名称、联系人
  - 可选唯一标识：供应商编号、营业执照号
  - 存储特点：永久存储



## 2. 逻辑设计

### 2.1 ER图

- 关系
- 元组
- 属性
- 候选码
- 主码
- 域
- 分量

### 2.2 设计范式概要

- 操作异常
  - 插入异常：如果某实体随着另一个实体的存在而存在，即缺少某个实体时无法表示这个实体，那么这个表就存在插入异常
  - 更新异常：如果更改表所对应的某个实体实例的单独属性时，需要将多行更新，那么就说这个表存在更新异常
  - 删除异常：如果删除表的某一行来反映某实体实例失效时导致另一个不同实体实例信息丢失，那么这个表中就存在删除异常
- 数据冗余
  - 指相同的数据在多个地方存在，或者说表中的某个列可以由其他列计算得到

### 2.3 第一范式 1NF

- 定义：数据库表中的所有字段都是单一属性，不可再分的。基本数据类型，整数、浮点数、字符串
- 第一范式要求数据库中的表都是二维表

### 2.4 第二范式 2NF

- 定义：数据库的表中不存在非关键字段对任一候选关键字段的部分函数依赖。部分函数依赖是指存在着组合关键字中的某一关键字决定非关键字的情况
- 所有单关键字段的表都符合第二范式

### 2.5 第三范式

- 定义：第三范式是在第二范式的基础上定义的，如果数据表中不存在非关键字段，对任意候选关键字段的传递函数依赖则符合第三范式

### 2.6 BC范式

- 定义：在第三范式的基础之上，数据库表中如果不存在任何字段对任一候选关键字段的传递函数依赖则符合BC范式
- 如果是复合关键字，则复合关键字之间也不能存在函数依关系

## 3. 物理设计

### 3.1 数据库物理设计要做什么

- 选择合适的数据库管理系统
- 定义数据库、表及字段的命名规范
- 根据所选的DBMS系统选择合适的字段类型
- 反范式化设计

### 3.2 MySQL常用存储引擎

| 存储引擎    | 事务 | 锁粒度               | 主要应用                       | 忌用                     |
| ----------- | ---- | -------------------- | ------------------------------ | ------------------------ |
| MyISAM      | 不   | 支持并发插入的表级锁 | SELECT,INSERT                  | 读写操作频繁             |
| MRG_MYISAM  | 不   | 支持并发插入的表级锁 | 分段归档，数据仓库             | 全局查找过多             |
| Innodb      | 支持 | 支持MVCC的行级锁     | 事务处理                       | 无                       |
| Archive     | 不   | 行级锁               | 日志记录，只支持insert，select | 需要随机读取，更新，删除 |
| Ndb cluster | 支持 | 行级锁               | 高可用性                       | 大部分应用               |

### 3.3 表及字段的命名规则

- 原则：
  - 可读性
  - 表意性原则

### 3.4 字段类型的选择

- 当一个列可以选择多种数据类型时，应该优先考虑数字类型，其次是日期或二进制类型，最后是字符串类型。对相同级别的数据类型，应该优先选择占用空间小的数据类型

  |     列类型 | 存储空间                     |
  | ---------: | ---------------------------- |
  |    TINYINT | 1字节                        |
  |   SMALLINT | 2字节                        |
  |  MEDIUMINT | 3字节                        |
  |        INT | 4字节                        |
  |     BIGINT | 8字节                        |
  |       DATE | 3字节                        |
  |   DATETIME | 9字节                        |
  |  TIMESTAMP | 4字节                        |
  |    CHAR(M) | M字节，1<=M<=255             |
  | VARCHAR(M) | L+1字节，在此L<=M和1<=M<=255 |

- 在对数据进行比较（查询条件、JSON条件及排序）操作时：**同样的数据，字符处理往往比数字处理慢**

- 在数据库中，数据处理以页为单位，**列的长度越小，利于性能提升**

- char与varchar选择

  - 如果长度差不多一致，考虑char
  - 如果小于50Byte，考虑char；大于的话使用varchar

- decimal与float选择

  - decimal用于存储精确数据，
  - float的存储空间开销一般比decimal小
  - 优先选择float

- 时间类型存储

  - 使用int 只能 存储到2038-1-19

### 3.5 如何选择主键

- 区分业务主键和数据库主键
  - 业务主键用于标识业务数据，进行表与表之间的关联
  - 数据库主键为了优化数据存储(Innodb生成6个字节的隐含主键)
- 根据数据库的类型，考虑主键是否要顺序增长
  - 有些数据库是按主键的顺序逻辑存储的
- 主键的字段类型所占空间要尽可能的小
  - 对于使用聚集索引方式存储的表，每个索引后都会附加主键信息

避免使用外键约束

- 降低数据导入的效率
- 增加维护成本
- 虽然不建议使用外键约束，但是相关联的列上一定要建立索引

避免使用触发器

- 降低数据导入的效率
- 可能会出现意想不到的数据异常
- 使业务逻辑变的复杂
- 严禁使用预留字段

### 3.6 反范式化表设计

- 反范式化是针对范式化而言的，是为了性能和读取效率的考虑而适当的对第三范式的要求进行违反
- 反范式化就是使用空间来换取时间
- 减少表的关联数量、增加数据的读取效率、反范式化一定要适度

## 4.维护优化

### 4.1 维护数据字典

- 使用第三方工具对数据字典进行维护
- 

### 4.2 维护索引



### 4.3 维护表结构

### 4.4 在适当的时候对表进行水平拆分或垂直拆分